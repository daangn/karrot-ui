{
  "name": "multiline-text-field",
  "dependencies": [
    "@seed-design/react-text-field",
    "@daangn/react-monochrome-icon"
  ],
  "registries": [
    {
      "name": "multiline-text-field.tsx",
      "type": "ui",
      "content": "\"use client\";\n\nimport \"@seed-design/stylesheet/textField.css\";\n\nimport * as React from \"react\";\nimport clsx from \"clsx\";\nimport {\n  textField,\n  type TextFieldVariantProps,\n} from \"@seed-design/recipe/textField\";\nimport { IconExclamationmarkCircleFill } from \"@daangn/react-monochrome-icon\";\nimport {\n  useTextField,\n  type UseTextFieldProps,\n} from \"@seed-design/react-text-field\";\nimport type { Assign } from \"../util/types\";\n\nexport interface MultilineTextFieldProps\n  extends UseTextFieldProps,\n    TextFieldVariantProps {\n  label?: string;\n  requiredIndicator?: string;\n  optionalIndicator?: string;\n\n  description?: string;\n  errorMessage?: string;\n\n  maxGraphemeCount?: number;\n  hideGraphemeCount?: boolean;\n}\n\ntype ReactMultilineTextFieldProps = Assign<\n  Omit<\n    React.TextareaHTMLAttributes<HTMLTextAreaElement>,\n    \"children\" | \"maxLength\"\n  >,\n  MultilineTextFieldProps\n>;\n\nconst useLayoutEffect = globalThis?.document\n  ? React.useLayoutEffect\n  : React.useEffect;\n\nexport const MultilineTextField = React.forwardRef<\n  HTMLTextAreaElement,\n  ReactMultilineTextFieldProps\n>(\n  (\n    {\n      size = \"medium\",\n      label,\n      requiredIndicator,\n      optionalIndicator,\n      hideGraphemeCount,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const {\n      rootProps: { className: rootClassName, ...rootProps },\n      textareaProps: { className: textareaClassName, ...textareaProps },\n      labelProps: { className: labelClassName, ...labelProps },\n      descriptionProps,\n      errorMessageProps,\n      stateProps,\n      restProps: restInternalProps,\n      isInvalid,\n      isRequired,\n      graphemes,\n      value,\n    } = useTextField({ elementType: \"textarea\", ...restProps });\n\n    const { description, errorMessage, maxGraphemeCount, style } = restProps;\n\n    const classNames = textField({ size });\n\n    const indicator = isRequired ? requiredIndicator : optionalIndicator;\n\n    const renderDescription = !isInvalid && description;\n    const renderErrorMessage = isInvalid && !!errorMessage;\n    const renderCharacterCount = !hideGraphemeCount && maxGraphemeCount;\n\n    // referenced from React Spectrum\n    const inputRef = React.useRef<HTMLTextAreaElement>(null);\n    const onHeightChange = React.useCallback(() => {\n      // Quiet textareas always grow based on their text content.\n      // Standard textareas also grow by default, unless an explicit height is set.\n      if (style?.height && inputRef.current) {\n        const input = inputRef.current;\n        input.style.height = \"\";\n      }\n      if (!style?.height && inputRef.current) {\n        const input = inputRef.current;\n        const prevAlignment = input.style.alignSelf;\n        const prevOverflow = input.style.overflow;\n        // Firefox scroll position is lost when overflow: 'hidden' is applied so we skip applying it.\n        // The measure/applied height is also incorrect/reset if we turn on and off\n        // overflow: hidden in Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1787062\n        const isFirefox = \"MozAppearance\" in input.style;\n        if (!isFirefox) {\n          input.style.overflow = \"hidden\";\n        }\n        input.style.alignSelf = \"start\";\n        input.style.height = \"auto\";\n        // offsetHeight - clientHeight accounts for the border/padding.\n        input.style.height = `${\n          input.scrollHeight + (input.offsetHeight - input.clientHeight)\n        }px`;\n        input.style.overflow = prevOverflow;\n        input.style.alignSelf = prevAlignment;\n      }\n    }, [inputRef, style?.height]);\n\n    useLayoutEffect(() => {\n      if (inputRef.current) {\n        onHeightChange();\n      }\n    }, [onHeightChange, value, inputRef]);\n\n    return (\n      <div\n        className={clsx(classNames.root, rootClassName)}\n        {...rootProps}\n        {...stateProps}\n      >\n        {label && (\n          // XXX\n          // biome-ignore lint/a11y/noLabelWithoutControl: <explanation>\n          <label {...labelProps} className={classNames.header}>\n            <span className={clsx(classNames.label, labelClassName)}>\n              {label}\n            </span>\n            {indicator && (\n              <span className={classNames.indicator}>{indicator}</span>\n            )}\n          </label>\n        )}\n        <div className={classNames.input}>\n          <textarea\n            rows={3}\n            ref={mergeRefs(ref, inputRef)}\n            className={clsx(classNames.inputText, textareaClassName)}\n            {...textareaProps}\n            {...restInternalProps}\n          />\n        </div>\n        {(renderDescription || renderErrorMessage || renderCharacterCount) && (\n          <div className={classNames.footer}>\n            {renderDescription && (\n              <div {...descriptionProps} className={classNames.description}>\n                {description}\n              </div>\n            )}\n            {renderErrorMessage && (\n              <div {...errorMessageProps} className={classNames.errorMessage}>\n                <IconExclamationmarkCircleFill\n                  className={classNames.errorIcon}\n                />\n                <div>{errorMessage}</div>\n              </div>\n            )}\n            {renderCharacterCount && (\n              <div className={classNames.graphemeCount}>\n                <span\n                  {...stateProps}\n                  className={classNames.currentGraphemeCount}\n                >\n                  {graphemes.length}\n                </span>\n                <span className={classNames.maxGraphemeCount}>\n                  /{maxGraphemeCount}\n                </span>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  },\n);\nMultilineTextField.displayName = \"MultilineTextField\";\n\nfunction mergeRefs<T>(...refs: React.ForwardedRef<T>[]): React.ForwardedRef<T> {\n  if (refs.length === 1) {\n    return refs[0];\n  }\n\n  return (value: T | null) => {\n    for (const ref of refs) {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    }\n  };\n}\n"
    }
  ]
}