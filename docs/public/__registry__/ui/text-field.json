{
  "name": "text-field",
  "dependencies": [
    "@seed-design/react-text-field@0.0.0-alpha-20241030023710",
    "@daangn/react-monochrome-icon",
    "@radix-ui/react-slot"
  ],
  "registries": [
    {
      "name": "text-field.tsx",
      "type": "ui",
      "content": "\"use client\";\n\nimport \"@seed-design/stylesheet/textField.css\";\n\nimport * as React from \"react\";\nimport clsx from \"clsx\";\nimport {\n  textField,\n  type TextFieldVariantProps,\n} from \"@seed-design/recipe/textField\";\nimport { IconExclamationmarkCircleFill } from \"@daangn/react-monochrome-icon\";\nimport {\n  useTextField,\n  type UseTextFieldProps,\n} from \"@seed-design/react-text-field\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport type { Assign } from \"../util/types\";\n\nconst useLayoutEffect = globalThis?.document\n  ? React.useLayoutEffect\n  : React.useEffect;\n\nconst FormControlContext = React.createContext<{\n  api: ReturnType<typeof useTextField>;\n  variantProps: TextFieldVariantProps;\n} | null>(null);\n\nconst useFormControlContext = () => {\n  const context = React.useContext(FormControlContext);\n  if (!context)\n    throw new Error(\n      \"Parts of FormControl cannot be rendered outside the FormControl\",\n    );\n\n  return context;\n};\n\nexport interface FormControlProps\n  extends UseTextFieldProps,\n    TextFieldVariantProps {\n  requiredIndicator?: string;\n  optionalIndicator?: string;\n\n  hideGraphemeCount?: boolean;\n}\n\nexport const FormControl = React.forwardRef<\n  HTMLDivElement,\n  Assign<React.HTMLAttributes<HTMLDivElement>, FormControlProps>\n>(\n  (\n    {\n      children,\n      className,\n      size = \"medium\",\n      requiredIndicator,\n      optionalIndicator,\n      hideGraphemeCount,\n      ...otherProps\n    },\n    ref,\n  ) => {\n    const api = useTextField(otherProps);\n    const {\n      rootProps,\n      labelProps,\n      descriptionProps,\n      errorMessageProps,\n      renderDescription,\n      renderErrorMessage,\n      stateProps,\n      isRequired,\n      graphemes,\n    } = api;\n\n    const { label, description, errorMessage, maxGraphemeCount } = otherProps;\n\n    const classNames = textField({ size });\n\n    const indicator = isRequired ? requiredIndicator : optionalIndicator;\n\n    const renderGraphemeCount = !hideGraphemeCount && maxGraphemeCount;\n\n    return (\n      <div\n        ref={ref}\n        className={clsx(className, classNames.root)}\n        {...rootProps}\n        {...stateProps}\n      >\n        {label && (\n          // XXX\n          // biome-ignore lint/a11y/noLabelWithoutControl: <explanation>\n          <label {...labelProps} className={classNames.header}>\n            <span className={classNames.label}>{label}</span>\n            {indicator && (\n              <span className={classNames.indicator}>{indicator}</span>\n            )}\n          </label>\n        )}\n        <FormControlContext.Provider value={{ api, variantProps: { size } }}>\n          {children}\n        </FormControlContext.Provider>\n        {(renderDescription || renderErrorMessage || renderGraphemeCount) && (\n          <div className={classNames.footer}>\n            {renderDescription && (\n              <div {...descriptionProps} className={classNames.description}>\n                {description}\n              </div>\n            )}\n            {renderErrorMessage && (\n              <div {...errorMessageProps} className={classNames.errorMessage}>\n                <IconExclamationmarkCircleFill\n                  className={classNames.errorIcon}\n                />\n                <div>{errorMessage}</div>\n              </div>\n            )}\n            {renderGraphemeCount && (\n              <div className={classNames.characterCount}>\n                <span\n                  {...stateProps}\n                  className={classNames.currentCharacterCount}\n                >\n                  {graphemes.length}\n                </span>\n                <span className={classNames.maxCharacterCount}>\n                  /{maxGraphemeCount}\n                </span>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  },\n);\nFormControl.displayName = \"FormControl\";\n\nexport interface TextFieldProps {\n  // XXX: 둘 다 받지는 못하면 좋을 것 같음\n  prefix?: string;\n  prefixIcon?: React.ReactNode;\n\n  // XXX: 둘 다 받지는 못하면 좋을 것 같음\n  suffix?: string;\n  suffixIcon?: React.ReactNode;\n}\n\nexport const TextField = React.forwardRef<\n  HTMLInputElement,\n  Assign<\n    Omit<React.InputHTMLAttributes<HTMLInputElement>, \"children\">,\n    TextFieldProps\n  >\n>(\n  (\n    { className, prefix, prefixIcon, suffix, suffixIcon, ...otherProps },\n    ref,\n  ) => {\n    const { api, variantProps } = useFormControlContext();\n\n    const { inputProps, restProps, stateProps } = api;\n\n    const classNames = textField(variantProps);\n\n    return (\n      <div {...stateProps} className={clsx(className, classNames.input)}>\n        {prefix && <div className={classNames.prefixText}>{prefix}</div>}\n        {prefixIcon && (\n          <Slot {...stateProps} className={clsx(classNames.prefixIcon)}>\n            {prefixIcon}\n          </Slot>\n        )}\n        <input\n          ref={ref}\n          className={clsx(classNames.inputText)}\n          {...inputProps}\n          {...restProps}\n          {...otherProps}\n        />\n        {suffix && <div className={classNames.suffixText}>{suffix}</div>}\n        {suffixIcon && (\n          <Slot {...stateProps} className={clsx(classNames.suffixIcon)}>\n            {suffixIcon}\n          </Slot>\n        )}\n      </div>\n    );\n  },\n);\nTextField.displayName = \"TextField\";\n\nexport type MultilineTextFieldProps = {};\n\nexport const MultilineTextField = React.forwardRef<\n  HTMLTextAreaElement,\n  Assign<\n    Omit<React.TextareaHTMLAttributes<HTMLTextAreaElement>, \"children\">,\n    MultilineTextFieldProps\n  >\n>(({ className, ...otherProps }, ref) => {\n  const { api, variantProps } = useFormControlContext();\n\n  const { inputProps, restProps, value } = api;\n\n  const classNames = textField(variantProps);\n\n  // referenced from React Spectrum\n  const inputRef = React.useRef<HTMLTextAreaElement>(null);\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intended\n  const onHeightChange = React.useCallback(() => {\n    if (!inputRef.current) return;\n    if (otherProps.style?.height) return;\n\n    // Quiet textareas always grow based on their text content.\n    // Standard textareas also grow by default, unless an explicit height is set.\n\n    const input = inputRef.current;\n    const prevAlignment = input.style.alignSelf;\n    const prevOverflow = input.style.overflow;\n    // Firefox scroll position is lost when overflow: 'hidden' is applied so we skip applying it.\n    // The measure/applied height is also incorrect/reset if we turn on and off\n    // overflow: hidden in Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1787062\n    const isFirefox = \"MozAppearance\" in input.style;\n    if (!isFirefox) {\n      input.style.overflow = \"hidden\";\n    }\n\n    input.style.alignSelf = \"start\";\n    input.style.height = \"auto\";\n\n    // offsetHeight - clientHeight accounts for the border/padding.\n    input.style.height = `${\n      input.scrollHeight + (input.offsetHeight - input.clientHeight)\n    }px`;\n\n    input.style.overflow = prevOverflow;\n    input.style.alignSelf = prevAlignment;\n  }, [inputRef, otherProps.style?.height]);\n\n  useLayoutEffect(() => {\n    if (inputRef.current) {\n      onHeightChange();\n    }\n  }, [onHeightChange, value, inputRef]);\n\n  return (\n    <textarea\n      rows={1}\n      ref={mergeRefs(inputRef, ref)}\n      className={clsx(className, classNames.input, classNames.inputText)}\n      {...inputProps}\n      {...restProps}\n      {...otherProps}\n    />\n  );\n});\n\n// TODO: migrate\nfunction mergeRefs<T>(...refs: React.ForwardedRef<T>[]): React.ForwardedRef<T> {\n  if (refs.length === 1) {\n    return refs[0];\n  }\n\n  return (value: T | null) => {\n    for (const ref of refs) {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    }\n  };\n}\nMultilineTextField.displayName = \"MultilineTextField\";\n"
    }
  ]
}